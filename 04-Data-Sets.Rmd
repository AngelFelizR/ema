# Datasets and models {#dataSetsIntro}

We will illustrate the methods presented in this book by using two datasets related to: 
   
* predicting probability of survival for passengers of the *RMS Titanic*; 
* predicting prices of *apartments in Warsaw*.

The first dataset will be used to illustrate the application of the techniques in the case of a predictive model for a binary dependent variable. The second one will offer an example for models for a continuous variable.

In this chapter, we provide a short description of each of the datasets, together with results of exploratory analyses. We also introduce models that will be used for illustration purposes in subsequent chapters. 

## Sinking of the RMS Titanic {#TitanicDataset}

![Titanic sinking by Willy St√∂wer](figure/Titanic.jpg)

Sinking of the RMS Titanic is one of the deadliest maritime disasters in history (during peacetime). Over 1500 people died as a consequence of collision with an iceberg. Projects like *Encyclopedia titanica* (https://www.encyclopedia-titanica.org/) are a source of rich and precise data about Titanic's passengers. 
The `stablelearner` package in R includes a data frame with information about passengers' characteristics. The dataset, after some data cleaning and variable transformations, is also available in the `DALEX` package. In particular, the `titanic` data frame contains 2207 observations (for 1317 passengers and 890 crew members) and nine variables:

* *gender*, person's (passenger's or crew member's) gender, a factor (categorical variable) with two levels (categories): "male" (78%) and "female" (22%);
* *age*, person's age in years, a numerical variable; the age is given in (integer) years, in the range of 0--74 years; 
* *class*, the class in which the passenger travelled, or the duty class of a crew member; a factor with seven levels: "1st" (14.7%), "2nd" (12.9%), "3rd" (32.1%), "deck crew" (3%), "engineering crew" (14.7%), "restaurant staff" (3.1%), and "victualling crew" (19.5%);
* *embarked*, the harbor in which the person embarked on the ship, a factor with four levels: "Belfast" (8.9%), "Cherbourg" (12.3%), "Queenstown" (5.6%), and "Southampton" (73.2%);
* *country*, person's home country, a factor with 48 levels; the most common levels are "England" (51%), "United States" (12%), "Ireland" (6.2%), and "Sweden" (4.8%);
* *fare*, the price of the ticket (only available for passengers; 0 for crew members), a numerical variable in the range of 0--512;
* *sibsp*, the number of siblings/spouses aboard the ship, a numerical variable in the range of 0--8;
* *parch*, the number of parents/children aboard the ship, a numerical variable in the range of 0--9;
* *survived*, a factor with two levels: "yes" (67.8%) and "no" (32.2%) indicating whether the person survived or not.

The R code below allows obtaining more information about the contents of the dataset, values of the variables, etc.

```{r, warning=FALSE, message=FALSE}
library("DALEX")
head(titanic, 3)
```

Models considered for this dataset will use *survived* as the (binary) dependent variable. 

### Data exploration {#exploration-titanic}

As discussed in Chapter \@ref(modelDevelopmentProcess) [TOMASZ: CHECK THE CHAPTER NUMBER; IT SHOULD BE 2], it is always advisable to explore data before modelling. However, as this book is focused on model exploration, we will limit the data exploration part.

Before exploring the data, we first conduct some pre-processing. In particular, the value of variables *age*, *country*, *sibsp*, *parch*, and *fare* is missing for a limited number of observations (2, 81, 10, 10, and 26, respectively). Analyzing data with missing values is a topic on its own [@Schafer1997; @LittleRubin2002; @MolKen2007]. An often-used approach is to impute the missing values. Toward this end, multiple imputation should be considered [@Schafer1997; @MolKen2007; @vanBuuren2012]. However, given the limited number of missing values and the intended illustrative use of the dataset, we will limit ourselves to, admittedly inferior, single imputation. In particular, we replace the missing *age* values by the mean of the observed ones, i.e., 30:

```{r, warning=FALSE, message=FALSE}
titanic$age[is.na(titanic$age)] = 30
```

Missing *country* will be coded by "X":

```{r, warning=FALSE, message=FALSE}
titanic$country <- as.character(titanic$country)
titanic$country[is.na(titanic$country)] = "X"
titanic$country <- factor(titanic$country)
```

For *sibsp* and *parch*, we replace the missing values by the most frequently observed value, i.e., 0: 

```{r, warning=FALSE, message=FALSE}
titanic$sibsp[is.na(titanic$sibsp)] = 0
titanic$parch[is.na(titanic$parch)] = 0
```

Finally, for *fare*, we use the mean fare for a given *class*, i.e., 0 pounds for crew, 89 pounds for the 1st, 22 pounds for the 2nd, and 13 pounds for the 3rd class:

```{r, warning=FALSE, message=FALSE}
titanic$fare[is.na(titanic$fare) & titanic$class == "1st"] = 89
titanic$fare[is.na(titanic$fare) & titanic$class == "2nd"] = 22
titanic$fare[is.na(titanic$fare) & titanic$class == "3rd"] = 13
```

After imputing the missing values, we investigate the association between survival status and other variables. Most variables in the Titanic dataset are categorical, except *age* and *fare*. In order to keep the exploration uniform, we first transformed them into categorical variables. Figure \@ref(fig:titanicExplorationHistograms) shows histograms for both variables. *Age* is discretized into five categories resulting from cutoffs equal to 5, 10, 20, and 30, while *fare* is discretized by applying cutoffs equal to 1, 10, 25, and 50.

(ref:titanicExplorationHistogramsCaption) Histograms for variables *age* and *fare* for the Titanic data.

```{r titanicExplorationHistograms, warning=FALSE, message=FALSE, echo=FALSE, fig.width=11, fig.height=6, fig.cap='(ref:titanicExplorationHistogramsCaption)', out.width = '100%', fig.align='center'}
library("ggplot2")
library("ggmosaic")
library("patchwork")
library("forcats")
titanic$age_cat   <- cut(titanic$age, c(0,5,10,20,30,100), c("0-5","6-10","11-20","21-30","30+"), include.lowest = TRUE)
titanic$parch_cat <- cut(titanic$parch, c(-1, 0, 1, 2, 100), labels = c("0", "1", "2", "3+"))
titanic$sibsp_cat <- cut(titanic$sibsp, c(-1, 0, 1, 2, 100), labels = c("0", "1", "2", "3+"))
titanic$country_cat <- fct_lump(titanic$country, 8)
titanic$fare_cat  <- cut(titanic$fare, c(-1,0,10,25,50,520), c("0","1-10","10-24","25-50","50+"), include.lowest = TRUE)

pl01 <- ggplot(titanic, aes(age)) +
  geom_histogram(binwidth = 5, color = "white") + 
  theme_drwhy() + ggtitle("Histogram for age")

pl02 <- ggplot(titanic, aes(fare)) +
  geom_histogram(binwidth = 10, color = "white") + 
  theme_drwhy() + ggtitle("Histogram for fare")

pl01 + pl02
```


Figures \@ref(fig:titanicExplorationGenderAge)--\@ref(fig:titanicExplorationCountryHarbor) present graphically the proportion of non- and survivors for different levels of the other variables with the use of mosaic plots. The width of the bars (on the x-axis) reflects the marginal distribution (proportions) of the observed levels of the variable. On the other hand, the height of the bars (on the y-axis) provides the information about the proportion of non- and survivors. The graphs for *age* and *fare* were constructed by using the categorized versions of the variables.

Figure \@ref(fig:titanicExplorationGenderAge) indicates that the proportion of survivors was larger for females and children below 5 years of age. This is most likely the result of the "women and children first" principle that is often evoked in situations that require evacuation of persons whose life is in danger. 

(ref:titanicExplorationGenderAgeCaption) Survival according to gender and age category in the Titanic data. [TOMASZ: LABELS ON THE AXES? DIFFICULT TO READ PLOTS WITHOUT THEM.]

```{r titanicExplorationGenderAge, warning=FALSE, message=FALSE, echo=FALSE, fig.width=11, fig.height=6, fig.cap='(ref:titanicExplorationGenderAgeCaption)', out.width = '100%', fig.align='center'}
pl1 <- ggplot(data = titanic) +
   geom_mosaic(aes(x = product(survived, gender), fill=survived)) +
   labs(x="Gender", y="Survived?", title='Survival by gender') + theme_drwhy() + theme(legend.position = "none", panel.grid = element_blank()) +  scale_fill_manual(values = colors_discrete_drwhy(2))

pl2 <- ggplot(data = titanic) +
   geom_mosaic(aes(x = product(survived, age_cat), fill=survived)) +
   labs(x="Age", y="Survived?", title='Survival by age category') + theme_drwhy() + theme(legend.position = "none", panel.grid = element_blank()) + scale_fill_manual(values = colors_discrete_drwhy(2))

pl1 + pl2
```

The principle can, perhaps, partially explain the trend seen in Figure \@ref(fig:titanicExplorationParch), i.e., a higher proportion of survivors among those with 1-2 parents/children and 1-2 siblings/spouses aboard. 

(ref:titanicExplorationParchCaption) Survival according to the number of parents/children and siblings/spouses in the Titanic data. [TOMASZ: LABELS ON THE AXES? DIFFICULT TO READ PLOTS WITHOUT THEM.]

```{r titanicExplorationParch, warning=FALSE, message=FALSE, echo=FALSE, fig.width=11, fig.height=6, fig.cap='(ref:titanicExplorationParchCaption)', out.width = '100%', fig.align='center'}
pl3 <- ggplot(data = titanic) +
   geom_mosaic(aes(x = product(survived, parch_cat), fill=survived)) +
   labs(x="Number of parents/children aboard", y="Survived?", title='Survival by # of parents/children') + theme_drwhy() + theme(legend.position = "none", panel.grid = element_blank()) + scale_fill_manual(values = colors_discrete_drwhy(2))

pl4 <- ggplot(data = titanic) +
   geom_mosaic(aes(x = product(survived, sibsp_cat), fill=survived)) +
   labs(x="Number of siblings/spouses aboard", y="Survived?", title='Survival by # of siblings/spouses') + theme_drwhy() + theme(legend.position = "none", panel.grid = element_blank()) +  scale_fill_manual(values = colors_discrete_drwhy(2))

pl3 + pl4
```

Figure \@ref(fig:titanicExplorationClassFare) indicates that passengers travelling in the first and second class had a higher chance of survival, perhaps due to the proximity of the location of their cabins to the deck. Interestingly, the proportion of survivors among crew deck was similar to the proportion of the first-class passengers. The figure also shows that the proportion of survivors increased with the fare, which is consistent with the fact that the proportion was higher for passengers travelling in the first and second class. 

(ref:titanicExplorationClassFareCaption) Survival according to travel-class and ticket-fare in the Titanic data. [TOMASZ: LABELS ON THE AXES? DIFFICULT TO READ PLOTS WITHOUT THEM.]

```{r titanicExplorationClassFare, warning=FALSE, message=FALSE, echo=FALSE, fig.width=11, fig.height=6, fig.cap='(ref:titanicExplorationClassFareCaption)', out.width = '100%', fig.align='center'}
pl5 <- ggplot(data = titanic) +
   geom_mosaic(aes(x = product(survived, class), fill=survived)) +
   labs(x="Passenger class", y="Survived?", title='Survival by class') + theme_drwhy() + theme(legend.position = "none", axis.text.x = element_text(angle = 90), panel.grid = element_blank()) + scale_fill_manual(values = colors_discrete_drwhy(2))

pl6 <- ggplot(data = titanic) +
   geom_mosaic(aes(x = product(survived, fare_cat), fill=survived)) +
   labs(x="Fare", y="Survived?", title='Survival by fare category') + theme_drwhy() + theme(legend.position = "none", panel.grid = element_blank()) + scale_fill_manual(values = colors_discrete_drwhy(2))

pl5 + pl6
```

Finally, Figure \@ref(fig:titanicExplorationCountryHarbor) does not suggest any noteworthy trends.

(ref:titanicExplorationCountryHarborCaption) Survival according to the embarked harbor and country in the Titanic data. [TOMASZ: LABELS ON THE AXES? DIFFICULT TO READ PLOTS WITHOUT THEM.]

```{r titanicExplorationCountryHarbor, warning=FALSE, message=FALSE, echo=FALSE, fig.width=11, fig.height=6, fig.cap='(ref:titanicExplorationCountryHarborCaption)', out.width = '100%', fig.align='center'}

pl7 <- ggplot(data = titanic) +
   geom_mosaic(aes(x = product(survived, embarked), fill=survived)) +
   labs(x="Embarked harbor", y="Survived?", title='Survival by harbor') + theme_drwhy() + theme(legend.position = "none", axis.text.x = element_text(angle = 90), panel.grid = element_blank()) + scale_fill_manual(values = colors_discrete_drwhy(2))

pl8 <- ggplot(data = titanic) +
   geom_mosaic(aes(x = product(survived, country_cat), fill=survived)) +
   labs(x="Country", y="Survived?", title='Survival by country') + theme_drwhy() + theme(legend.position = "none", axis.text.x = element_text(angle = 90), panel.grid = element_blank()) + scale_fill_manual(values = colors_discrete_drwhy(2))

pl7 + pl8
```


### Logistic-regression model {#model-titanic-lmr}

The dependent variable of interest, *survived*, is binary. Thus, a natural choice is to start the predictive modelling with a logistic-regression model. As there is no reason to expect a linear relationship between age and odds of survival, we use linear tail-restricted cubic splines, available in the `rcs()` function of the `rms` package [@rms], to model the effect of age. We also do not expect linear relation for the *fare* variable, but because of its skewness (see Figure \@ref(fig:titanicExplorationHistograms)), we do not use splines for this variable. The results of the model are stored in model-object `titanic_lmr_v6`, which will be used in subsequent chapters. 
 
```{r, warning=FALSE, message=FALSE}
library("rms")
titanic_lmr_v6 <- lrm(survived == "yes" ~ gender + rcs(age) + class +
         sibsp + parch + fare + embarked, titanic)
titanic_lmr_v6
```

Note that we are not very much interested in the assessment of the model's predictive performance, but rather on understanding how does the model yield its predictions. This is why we do not split the data into the training and  testing subsets. Instead, the model is fitted to the entire dataset and will be examined on the same dataset.

### Random-forest model {#model-titanic-rf}

As an alternative to the logistic-regression model we consider a random-forest model. Random-forest modelling is known for good predictive performance, ability to grasp low-order variable interactions, and stability [@randomForestBreiman]. To fit the model, we apply the `randomForest()` function, with default settings, from the package with the same name [@randomForest].  

In the first instance, we fit a model with the same set of explanatory variables as the logistic-regression model (see Section \@ref(model-titanic-lmr)). The results of the random-forest model are stored in model-object `titanic_rf_v6`.

```{r titanicRandomForest01, warning=FALSE, message=FALSE}
library("randomForest")
set.seed(1313)
titanic_rf_v6 <- randomForest(survived ~ class + gender + age + sibsp + parch + fare + embarked,
   data = titanic)
titanic_rf_v6
```

For comparison purposes, we also consider a model with only three explanatory variables: *class*, *gender*, and *age*. The results of the model are stored in model-object `titanic_rf_v3`. [TOMASZ: IS THIS THE MODEL FROM THE BREAK-DOWN INTUITION? IF NOT, DO WE EVER USE IT?]

```{r titanicRandomForest02, warning=FALSE, message=FALSE}
set.seed(1313)
titanic_rf_v3 <- randomForest(survived ~ class + gender + age, data = titanic)
titanic_rf_v3
```
   
### Gradient-boosting model {#model-titanic-gbm}

Additionally, we consider the gradient-boosting model [@Friedman00greedyfunction]. Tree-based-boosting models are known for being able to accommodate higher-order interactions between variables. We use the same set of six explanatory variables as for the logistic-regression model (see Section \@ref(model-titanic-lmr)). To fit the gradient-boosting model, we use function `gbm()` from the `gbm` package [@gbm]. The results of the model are stored in model-object `titanic_gbm_v6`.

```{r titanicGBM01, warning=FALSE, message=FALSE}
library("gbm")
set.seed(1313)
titanic_gbm_v6 <- gbm(survived == "yes" ~ class + gender + age + sibsp + 
         parch + fare + embarked, data = titanic, n.trees = 15000, 
         distribution = "bernoulli")
titanic_gbm_v6
```

### Support-vector-machine model {#model-titanic-svm}

Finally, we also consider a support-vector-machine model [@svm95vapnik]. We use the C-classification mode. Again, we fit a model with the same set of explanatory variables as in the logistic-regression model (see Section \@ref(model-titanic-lmr)) To fit the model, we use function `svm()` from the `e1071` package [@e1071]. The results of the model are stored in model-object `titanic_svm_v6`.

```{r titanicSVM01, warning=FALSE, message=FALSE}
library("e1071")
titanic_svm_v6 <- svm(survived == "yes" ~ class + gender + age + sibsp +
            parch + fare + embarked, data = titanic, 
            type = "C-classification", probability = TRUE)
titanic_svm_v6
```

### Models' predictions {#predictions-titanic}

Let us now compare predictions that are obtained from the different models. In particular, we compute the predicted probability of survival for Johnny D, an 8-year-old boy who embarked in Southampton and travelled in the first class with no parents nor siblings, and with a ticket costing 72 pounds. 

First, we create a dataframe `johnny_d` that contains the data describing the passenger.

```{r titanicPred01, warning=FALSE, message=FALSE}
johnny_d <- data.frame(
            class = factor("1st", levels = c("1st", "2nd", "3rd", "deck crew",
                        "engineering crew", "restaurant staff", "victualling crew")),
            gender = factor("male", levels = c("female", "male")),
            age = 8,
            sibsp = 0,
            parch = 0,
            fare = 72,
            embarked = factor("Southampton", levels = c("Belfast",
                        "Cherbourg","Queenstown","Southampton"))
)
```

Subsequently, we use the generic function `predict()` to obtain the predicted probability of survival for the logistic-regression model. 

```{r, warning=FALSE, message=FALSE}
(pred_lmr <- predict(titanic_lmr_v6, johnny_d, type = "fitted"))
```
The predicted probability is equal to `r round(pred_lmr, 2)`.

We do the same for the remaining three models.

```{r, warning=FALSE, message=FALSE}
(pred_rf <- predict(titanic_rf_v6, johnny_d, type = "prob"))
(pred_gbm <- predict(titanic_gbm_v6, johnny_d, type = "response", n.trees = 15000))
(pred_svm <- predict(titanic_svm_v6, johnny_d, probability = TRUE))
```

As a result, we obtain the predicted probabilities of `r round(pred_rf[1,2], 2)`, `r round(pred_gbm, 2)`, and `r round(attr(pred_svm,"probabilities")[,2], 2)` for the random-forest, gradient-boosting, and support-vector-machine models, respectively. The models lead to different probabilities. Thus, it might be of interest to understand the reason for the differences, as it could help us to decide which of the predictions we might want to trust. We will investigate this issue in the subsequent chapters.

Note that, for some examples later in the book, we will use another observation (instance) with lower chances of survival. We will call this passenger Henry.

```{r, warning=FALSE, message=FALSE}
henry <- data.frame(
         class = factor("1st", levels = c("1st", "2nd", "3rd", "deck crew", 
                     "engineering crew", "restaurant staff", "victualling crew")),
         gender = factor("male", levels = c("female", "male")),
         age = 47,
         sibsp = 0,
         parch = 0,
         fare = 25,
         embarked = factor("Cherbourg", levels = c("Belfast",
                           "Cherbourg","Queenstown","Southampton"))
)
predict(titanic_lmr_v6, henry, type = "fitted")
predict(titanic_rf_v6, henry, type = "prob")[,2]
predict(titanic_gbm_v6, henry, type = "response", n.trees = 15000)
attr(predict(titanic_svm_v6, henry, probability = TRUE),"probabilities")[,2]
```

### Models' explainers {#ExplainersTitanicRCode}

Model-objects created with different libraries may have different internal structures. Thus, first, we have got to create an "explainer," i.e., an object that provides an uniform interface for different models. Toward this end, we use the `explain()` function from the `DALEX` package [@DALEX]. As it was mentioned in Section \@ref(infoDALEX), there is only one argument that is required by the function, i.e., `model`. The argument is used to specify the model-object with the fitted form of the model. However, the function allows additional arguments that extend its functionalities. In particular, the list of arguments includes the following: 

* `data`, a data frame or matrix providing data to which the model is to be applied; if not provided (`data = NULL` by default), the data are extracted from the model-object. Note that the data object should notm in principle, contain the dependent variable.
* `y`, observed values of the dependent variable corresponding to the data given in the `data` object; if not provided (`y = NULL` by default), the values are extracted from the model-object;
* `predict_function`, a function that returns prediction scores; if not specified (`predict_function = NULL` by default), then a default `predict()` function is used (note that this may lead to errors); 
* `residual_function`, a function that returns model residuals; if not specified (`residual_function = NULL` by default), then model residuals defined in equation \@ref(eq:modelResiduals) are calculated;
* `verbose`, a logical argument (`verbose = TRUE` by default) indicating whether diagnostic messages are to be printed; 
* `precalculate`, a logical argument (`precalculate = TRUE` by default) indicating whether predicted values and residuals are to be calculated when the explainer is created. Note that this will also happen if `verbose = TRUE`. To skip the calculations, both `verbose` and `precalculate` should be set to FALSE .
* `model_info`, a named list (with components "package," "version," and "type") providing information about the model; if not specified (`model_info = NULL` by default), `DALEX` seeks for information on its own;
* `type`, information about the type of the model, either "classification" (for a binary dependent variable) or "regression" (for a continuous depenent variable); if not specified (`type = NULL` by default), then the value of the argument is extracted from `model_info`;
* `label`, a unique name of the model; if not specified (`label = NULL` by default), then it is extracted from `class(model)`. 

Application of function `explain()` provides an object of class "explainer." It is a list with many components that include:

* `model`, the explained model;
* `data`, the data to which the model is applied;
* `y`, observed values of the dependet variable corresponding to `data`;
* `y_hat`, predictions obtained by applying `model` to 'data`;
* `residuals`, residuals computed based on `y` and `y_hat`;
* `predict_function`, the function used to obtain the model's predictions;
* `residual_function`, the function used to obtain residuals;
* `class`,  class/classes of the model;
* `label`, label of the model/explainer;
* `model_info`, a named list (with components "package," "version," and "type") providing information about the model.

Thus, each explainer-object contains all elements needed to create a model explanation. The code below creates explainers for the models (see Sections \@ref(model-titanic-lmr)--\@ref(model-titanic-svm)) fitted to the Titanic data. Note that, in the `data` argument, we indicate the `titanic` data frame without the ninth column, i.e., without the *survived* variable. The variable is used in the `y` argument to explicitly define the binary dependent variable equal to 1 for survivors and 0 for passengers who did not survive.  

```{r, warning=FALSE, message=FALSE, eval=FALSE}
explain_titanic_lmr_v6 <- explain(model = titanic_lmr_v6, data = titanic[, -9],
    y = titanic$survived == "yes", label = "Logistic Regression", verbose = FALSE)
explain_titanic_lmr_v6$model_info$type = "classification"
explain_titanic_rf_v6 <- explain(model = titanic_rf_v6, data = titanic[, -9],
    y = titanic$survived == "yes", label = "Random Forest", verbose = FALSE)
explain_titanic_rf_v3 <- explain(model = titanic_rf_v3, data = titanic[, -9],
    y = titanic$survived == "yes", label = "Random Forest small", verbose = FALSE)
explain_titanic_gbm_v6 <- explain(model = titanic_gbm_v6, data = titanic[, -9],
    y = titanic$survived == "yes", label = "Generalized Boosted Regression", verbose = FALSE)
explain_titanic_svm_v6 <- explain(model = titanic_svm_v6, data = titanic[, -9],
    y = titanic$survived == "yes", label = "Support Vector Machine", verbose = FALSE)
```

```{r eval=FALSE, echo=FALSE}
# saveToLocalRepo(model_titanic_lmr, repoDir = "models")
# "56d8a46955e91f0472243e1af8021b96"
# saveToLocalRepo(explain_titanic_lmr_v6, repoDir = "models")
# "ff1cd6221c34ea70a9e033b5725c9585"

# saveToLocalRepo(titanic_rf_v6, repoDir = "models")
# "31570ec57a3b72d3ec83a5f9b22cbaaa"
# saveToLocalRepo(explain_titanic_rf_v6, repoDir = "models")
# "6ed54968790fbbe291acceb7dd6bc2ad"

# saveToLocalRepo(titanic_rf_v3, repoDir = "models")
# "855c117e1d08e793b820da14ccfdc7a5"
# saveToLocalRepo(explain_titanic_rf_v3, repoDir = "models")
# "5b32a9ed8ce5a1d63833706dbe38e221"

# saveToLocalRepo(titanic_gbm_v6, repoDir = "models")
# "0854469e60467cb25c3b7c48da5fd3dd"
# saveToLocalRepo(explain_titanic_gbm_v6, repoDir = "models")
# "87271254388a263c90ef3fa3a7a806ee"

# saveToLocalRepo(titanic_svm_v6, repoDir = "models")
# "be26e200fd6453088f5db791ac07471c"
# saveToLocalRepo(explain_titanic_svm_v6, repoDir = "models")
# "21966045bff86bba565814e8f1a18384"

```

### List of objects for the Titanic example  {#ListOfModelsTitanic}

In the previous sections, we have built four predictive models for the Titanic dataset. The models will be used in the rest of the book to illustrate model-explanation methods and tools. 

For the ease of reference, we summarize the models in Table \@ref(tab:archivistHooksOfModelsTitanic). The binary model-objects can be downloaded by using the indicated `archivist` hooks [@archivist]. By calling a function specified in the last column of the table, one can restore a selected model in its local R environment.

Table: (\#tab:archivistHooksOfModelsTitanic) Predictive models created for the `titanic` dataset. [TOMASZ: HOOKS FOR THE MODELS UPDATED AS GIVEN IN THE EMAIL. SVM 1.7.3]

| Model name   | Model generator | Variables  | Archivist hooks |
|--------------|-----------------|------------|-----------------|
| `titanic_lmr_v6`  | `rms:: lmr` v.5.1.3  | gender, age, class, sibsp, parch, fare, embarked |  Get the model: `archivist:: aread("pbiecek/models/58b24")`. Get the explainer: `archivist:: aread("pbiecek/models/ff1cd")` |
| `titanic_rf_v6`  | `randomForest:: randomForest`  v.4.6.14 | gender, age, class, sibsp, parch, fare, embarked | Get the model:  `archivist:: aread("pbiecek/models/4e0fc")`. Get the explainer: `archivist:: aread("pbiecek/models/6ed54")` |
| `titanic_rf_v3`  | `randomForest:: randomForest`  v.4.6.14 | gender, age, class  | Get the model:  `archivist:: aread("pbiecek/models/293e8")`. Get the explainer: `archivist:: aread("pbiecek/models/5b32a")` |
| `titanic_gbm_v6`  | `gbm:: gbm`  v.2.1.5 | gender, age, class, sibsp, parch, fare, embarked | Get the model:  `archivist:: aread("pbiecek/models/b7078")`. Get the explainer: `archivist:: aread("pbiecek/models/87271")` |
| `titanic_svm_v6`  | `e1071:: svm` v.1.7.3 | gender, age, class, sibsp, parch, fare, embarked | Get the model:  `archivist:: aread("pbiecek/models/9c27f")`. Get the explainer: `archivist:: aread("pbiecek/models/21966")` |

Table \@ref(tab:archivistHooksOfDataFramesTitanic) summarizes the data frames that will be used in examples in the subsequent chapters.  

Table: (\#tab:archivistHooksOfDataFramesTitanic) Data frames created for the `titanic` example. 

| Description  | No. rows | Variables  | Link to this object |
|--------------|----------|------------|---------------------|
| `titanic` dataset with imputed missing values  | 2207  | gender, age, class, embarked, country, fare, sibsp, parch, survived |  `archivist:: aread("pbiecek/models/27e5c")` |
| `johnny_d` 8-year-old boy from the 1st class without parents, paid 72 pounds, embarked in Southampton | 1 | class, gender, age, sibsp, parch, fare, embarked  |  `archivist:: aread("pbiecek/models/e3596")` |
| `henry` 47-year-old male from the 1st class, travelled alone, paid 25 pounds, embarked in Cherbourg  | 1 | class, gender, age, sibsp, parch, fare, embarked |  `archivist:: aread("pbiecek/models/a6538")`  |


## Apartment prices {#ApartmentDataset}

![Warsaw skyscrapers by Artur Malinowski Flicker](figure/am1974_flicker.jpg)

Predicting house prices is a common exercise used in machine-learning courses. Various datasets for house prices are available at websites like Kaggle (https://www.kaggle.com) or UCI Machine Learning Repository (https://archive.ics.uci.edu). 

In this book, we will work with an interesting variant of this problem. The `apartments` dataset is an artificial dataset created to match key characteristics of real apartments in Warsaw, the capital of Poland. However, the dataset is created in a way that two very different models, namely linear regression and random forest, have almost exactly the same accuracy. The natural question is then: which model should we choose? We will show that the model-explanation tools provide important insight into the key model characteristics and are helpful in model selection.

The dataset is available in the `DALEX` package [@DALEX]. It contains 1000 observations (apartments) and six variables:

* *m2.price*, apartment's price per square meter (in EUR), a numerical variable in the range of 1607--6595;
* *construction.year*, the year of construction of the block of flats in which the apartment is located, a numerical variable in the range of 1920--2010;
* *surface*, apartment's total surface in square meters, a numerical variable in the range of 20--150;
* *floor*, the floor at which the apartment is located (ground floor taken to be the first floor), a numerical integer variable with values ranging from 1 to 10;
* *no.rooms*, the total number of rooms, a numerical integer variable with values ranging from 1 to 6;
* *district*, a factor with 10 levels indicating the district of Warsaw where the apartment is located.

The R code below provides more information about the contents of the dataset and values of the variables.

```{r, warning=FALSE, message=FALSE}
library("DALEX")
head(apartments, 3)
```

Models considered for this dataset will use *m2.price* as the (continuous) dependent variable. Models' predictions will be obtained for a set of 9000 apartments included in data frame `apartments_test`. Below we present the first six observations from the data frame.  
[TOMASZ: APARTMENTS_TEST CONTAINS 9,000 OBSERVATIONS (IN DALEX)! MORE THAN APARTMENTS. SHOULD NOT WE USE APARTMENTS_TEST TO BUILD THE MODEL, AND USE APARTMENTS TO TEST IT?]

```{r, warning=FALSE, message=FALSE}
head(apartments_test,6)
```

### Data exploration {#exploration-apartments}

Note that `apartments` is an artificial dataset created to illustrate and explain differences between random forest and linear regression. Hence, the structure of the data, the form and strength of association between variables, plausibility of distributional assumptions, etc., is better than in a real-life dataset. In fact, all these characteristics of the data are known. Nevertheless, we present some data exploration below to illustrate the important aspects of the data.

The variable of interest is *m2.price*, the price per square meter. The histogram presented in Figure  \@ref(fig:apartmentsExplorationMi2) indicates that the distribution of the variable is slightly skewed to the right. 

(ref:apartmentsExplorationMi2Caption) Distribution of the price per square meter in the apartment-prices data.

```{r apartmentsExplorationMi2, warning=FALSE, message=FALSE, echo=FALSE, fig.width=6, fig.height=4, fig.cap='(ref:apartmentsExplorationMi2Caption)'}
ggplot(data = apartments) +
   geom_histogram(aes(m2.price), binwidth = 100, color = "white") +
   labs(x="Price per square meter", title='Histogram of apartment prices') + 
   theme_drwhy() + theme(legend.position = "none") 
```

Figure  \@ref(fig:apartmentsMi2Construction) suggests (possibly) a non-linear relationship between *construction.year* and *m2.price* and a linear relation between *surface* and *m2.price*.

(ref:apartmentsMi2ConstructionCaption) Apartment-prices data. Price per square meter vs. year of construction (left-hand-side panel) and vs. surface (right-hand-side panel).

```{r apartmentsMi2Construction, warning=FALSE, message=FALSE, echo=FALSE, fig.width=11, fig.height=6, fig.cap='(ref:apartmentsMi2ConstructionCaption)', out.width = '100%', fig.align='center'}
pa1 <- ggplot(data = apartments, aes(construction.year, m2.price)) +
   geom_point(size = 0.3) +
  geom_smooth(se = FALSE, size=1, color = "#371ea3") +
   labs(y="Price per square meter", x = "Construction year", 
   title='Apartment price per m2 vs. construction year') + theme_drwhy() +
   theme(legend.position = "none") 

pa2 <- ggplot(data = apartments, aes(surface, m2.price)) +
   geom_point(size = 0.3) +
  geom_smooth(se = FALSE, size=1, color = "#371ea3") +
   labs(y="Price per square meter", x = "Surface (square meter)", 
        title='Apartment price per m2 vs. surface') + theme_drwhy() + 
   theme(legend.position = "none") 

pa1 + pa2
```

Figure \@ref(fig:apartmentsMi2Floor) indicates that the relationship between *floor* and *m2.price* is also close to linear, as well as is the association between *no.rooms* and *m2.price* .

(ref:apartmentsMi2FloorCaption) Apartment-prices data. Price per square meter vs. floor (left-hand-side panel) and vs. number of rooms (right-hand-side panel).

```{r apartmentsMi2Floor, warning=FALSE, message=FALSE, echo=FALSE, fig.width=11, fig.height=6, fig.cap='(ref:apartmentsMi2FloorCaption)', out.width = '100%', fig.align='center'}
pa3 <- ggplot(data = apartments, aes(floor, m2.price)) +
    geom_boxplot(aes(group = floor), se = FALSE, size=0.5, fill = "#371ea3", color = "white", alpha=0.3) +
    geom_jitter(size = 0.3, width = 0.15, height = 0) +
#    geom_smooth(se = FALSE, size=1, color = "#371ea3") +
    labs(y="Price per square meter", x = "Floor", title='Apartment price per m2 vs. floor') + theme_drwhy() + theme(legend.position = "none")  + scale_x_continuous(breaks = 1:10)

pa4 <- ggplot(data = apartments, aes(no.rooms, m2.price, group = no.rooms)) +
    geom_boxplot(aes(group = no.rooms), se = FALSE, size=0.5, fill = "#371ea3", color = "white", alpha=0.3) +
   geom_jitter(size = 0.3, width = 0.15, height = 0) +
   labs(y="Price per square meter", x = "Number of rooms", title='Apartment price per m2 vs. number of rooms') + theme_drwhy() + theme(legend.position = "none") + scale_x_continuous(breaks = 1:6)

pa3 + pa4
```

Figure \@ref(fig:apartmentsSurfaceNorooms) shows that *surface* and *number of rooms* are positively associatied and that prices depend on district. In particular, box plots in Figure \@ref(fig:apartmentsSurfaceNorooms) indicate that the highest prices per square meter are observed in Srodmiescie (Downtown).

(ref:apartmentsSurfaceNoroomsCaption) Apartment-prices data. Surface vs. number of rooms (left-hand-side panel) and price per square meter for different districts  (right-hand-side panel).

```{r apartmentsSurfaceNorooms, warning=FALSE, message=FALSE, echo=FALSE, fig.width=11, fig.height=6, fig.cap='(ref:apartmentsSurfaceNoroomsCaption)', out.width = '100%', fig.align='center'}
pa5 <- ggplot(data = apartments, aes(no.rooms, surface, group = no.rooms)) +
    geom_boxplot(aes(group = no.rooms), se = FALSE, size=0.5, fill = "#371ea3", color = "white", alpha=0.3) +
   geom_jitter(size = 0.3, width = 0.15, height = 0) +
   labs(y="Surface (square meter)", x = "Number of rooms", title='Surface for # of rooms') + theme_drwhy() + theme(legend.position = "none")  + scale_x_continuous(breaks = 1:6)

apartments$district <- reorder(apartments$district, apartments$m2.price, mean)
pa6 <- ggplot(data = apartments, aes(district, m2.price)) +
    geom_boxplot(aes(group = district), se = FALSE, size=0.5, fill = "#371ea3", color = "white", alpha=0.3) +
    geom_jitter(size = 0.3, width = 0.15, height = 0) +
    labs(y="Price per square meter", x = "", title='Price per square meter for districts') + theme_drwhy_vertical() + theme(legend.position = "none") + coord_flip()

pa5 + pa6
```

### Linear-regression model {#model-Apartments-lr}

The dependent variable of interest, *m2.price*, is continuous. Thus, a natural choice to build a predictive model is linear regression. We treat all the other variables in the `apartments` data frame as explanatory and include them in the model. To fit the model, we apply the `lm()` function. The results of the model are stored in model-object `apartments_lm_v5`.

```{r, warning=FALSE, message=FALSE}
apartments_lm_v5 <- lm(m2.price ~ ., data = apartments)
anova(apartments_lm_v5)
```

### Random-forest model {#model-Apartments-rf}

As an alternative to linear regression, we consider a random-forest model. Again, we treat all the variables in the `apartments` data frame other than *m2.price* as explanatory and include them in the model. To fit the model, we apply the `randomForest()` function, with default settings, from the package with the same name [@randomForest]. The results of the model are stored in model-object `apartments_rf_v5`. 

```{r, warning=FALSE, message=FALSE, echo = TRUE, eval = FALSE}
library("randomForest")
set.seed(72)
apartments_rf_v5 <- randomForest(m2.price ~ ., data = apartments)
apartments_rf_v5
```

```{r, warning=FALSE, message=FALSE, echo=FALSE}
apartments_rf_v5 <- archivist::aread("pbiecek/models/fe7a5")
apartments_rf_v5
```

### Support-vector-machine model {#model-Apartments-svm}

Finally, we consider a support-vector-machine model, with all the variables in the `apartments` data frame other than *m2.price* treated as explanatory. To fit the model, we use the `svm()` function, with default settings, from package `e1071` [@R-e1071]. The results of the model are stored in model-object `apartments_svm_v5`. 

```{r, warning=FALSE, message=FALSE, eval = TRUE}
library("e1071")
apartments_svm_v5 <- svm(m2.price ~ construction.year + surface + floor + 
         no.rooms + district, data = apartments)
apartments_svm_v5
```

### Models' predictions {#predictionsApartments}

The `predict()` function calculates predictions for a specific model. In the example below, we use model-objects `apartments_lm_v5`, `apartments_rf_v5`, and `apartments_svm_v5`, to calculate predictions for prices of the apartments from the `apartments_test` data frame. Note that, for brevity sake, we compute the predictions only for the first six observations from the data frame. We also show the actual prices for the observations. 
[TOMASZ: SOMETHING IS WEIRD REGARDING THE PREDICTIONS FOR SVM. I AM GETTING 
    1001     1002     1003     1004     1005     1006 
2552.547 2153.783 2369.748 3596.214 2700.238 2736.293
HENCE A TRICK TO USE THE STORED SVM MODEL. IF THE SOURCE OF THE ISSUE IS FOUND, WE CAN SIMPLIFY THE CODE.] 

```{r, warning=FALSE, message=FALSE}
apartments_test$m2.price[1:6]
predict(apartments_lm_v5, apartments_test[1:6,])
predict(apartments_rf_v5, apartments_test[1:6,])
```

```{r, warning=FALSE, message=FALSE, eval = FALSE}
predict(apartments_svm_v5, apartments_test[1:6,])
```

```{r, warning=FALSE, message=FALSE, echo = FALSE, eval = TRUE}
predict(archivist::aread("pbiecek/models/d2ca0"), apartments_test[1:6,])
```

By using the code below, we summarize the predictive performance of the linear-regression and random-forest models by computing the square root of the mean-squared-error (RMSE). For a "perfect" predictive model, which would predict all observations exactly, RMSE should be equal to 0. More information about RMSE can be found in Section \@ref(modelPerformanceMethodCont).  

```{r, warning=FALSE, message=FALSE}
predicted_apartments_lm <- predict(apartments_lm_v5, apartments_test)
(rmsd_lm <- sqrt(mean((predicted_apartments_lm - apartments_test$m2.price)^2)))
predicted_apartments_rf <- predict(apartments_rf_v5, apartments_test)
(rmsd_rf <- sqrt(mean((predicted_apartments_rf - apartments_test$m2.price)^2)))
```

For the random-forest model, RMSE is equal to `r round(rmsd_rf, 1)`. It is almost identical to the RMSE for the linear-regression model, which is equal to `r round(rmsd_lm, 1)`. Thus, the question we may face is: should we choose the more complex, but flexible random-forest model, or the simpler and easier to interpret linear-regression model? In the subsequent chapters we will try to provide an answer to this question. In particular, we will show that a proper model exploration may help to discover weak and strong sides of any of the models and, in consequence, allow creation of a new model, with a better performance than either of the two.

### Models' explainers {#ExplainersApartmentsRCode}

The code below creates explainers for the models (see Sections \@ref(model-Apartments-lr)--\@ref(model-Apartments-svm)) fitted to the apartment-prices data. Note that we use the `apartments_test` data frame without the first column, i.e., the *m2.price* variable, in the `data` argument. This will be the dataset to which the model will be applied (see Section \@ref(ExplainersTitanicRCode)). The *m2.price* variable is explicitly specified as the dependent variable in the `y` argument (see Section \@ref(ExplainersTitanicRCode)). 

[TOMASZ: Y VARIABLE EXCLUDED FROM DATA. EXPLAINER-OBJECTS MAY REQUIRE AN UDPATE IN THE ARCHIVIST.]

```{r, warning=FALSE, message=FALSE, eval=FALSE}
explain_apartments_lm_v5 <- explain(model = apartments_lm_v5, data = apartments_test[,-1], 
    y = apartments_test$m2.price, label = "Linear Regression", verbose = FALSE)
explain_apartments_rf_v5 <- explain(model = apartments_rf_v5, data = apartments_test[,-1], 
    y = apartments_test$m2.price, label = "Random Forest", verbose = FALSE)
explain_apartments_svm_v5 <- explain(model = apartments_svm_v5, data = apartments_test[,-1], 
    y = apartments_test$m2.price, label = "Support Vector Machine", verbose = FALSE)
```

```{r eval=FALSE, echo=FALSE}
# saveToLocalRepo(explain_apartments_lm_v5, repoDir = "models")
# [1] "78d4ee073795205905fac2c1a48fd5d0" # explainer with test data
# saveToLocalRepo(explain_apartments_rf_v5, repoDir = "models")
# [1] "b173949f8825e3f6999203270f7f68f8" # explainer with test data
# saveToLocalRepo(explain_apartments_svm_v5, repoDir = "models")
# [1] "16602ee04b662ab8e7a930d81247bab6" # explainer with test data
```

### List of objects for the apartment prices example {#ListOfModelsApartments}

In Sections \@ref(model-Apartments-lr)--\@ref(model-Apartments-svm), we have built three predictive models for the `apartments` dataset. The models will be used in the rest of the book to illustrate the model-explanation methods and tools. 

For the ease of reference, we summarize the models in Table \@ref(tab:archivistHooksOfModelsApartments). The binary model-objects can be downloaded by using the indicated `archivist` hooks [@archivist]. By calling a function specified in the last column of the table, one can restore a selected model in a local R environment.

Table: (\#tab:archivistHooksOfModelsApartments) Predictive models created for the `apartments` dataset. [TOMASZ: HOOK FOR THE SVM MODEL UPDATED AS GIVEN IN THE EMAIL. SVM 1.7.3.] 

| Model name   | Model generator | Variables  | Archivist hooks |
|--------------|-----------------|------------|-----------------|
| `apartments_lm_v5`  | `stats:: lm` v.3.5.3  |  construction .year, surface, floor, no.rooms, district  | Get the model: `archivist:: aread("pbiecek/models/55f19")`. Get the explainer:  `archivist:: aread("pbiecek/models/78d4e")` |
|  `apartments_rf_v5` | `randomForest:: randomForest` v.4.6.14 | construction .year, surface, floor, no.rooms, district  | Get the model: `archivist:: aread("pbiecek/models/fe7a5")`. Get the explainer: `archivist:: aread("pbiecek/models/b1739")` |
|  `apartments_svm_v5` | `e1071:: svm` v.1.7.3 | construction .year, surface, floor, no.rooms, district  | Get the model: `archivist:: aread("pbiecek/models/d2ca0")`. Get the explainer: `archivist:: aread("pbiecek/models/16602")` |

[TOMASZ: NO TABLE WITH DATASETS, AS FOR TITANIC?]